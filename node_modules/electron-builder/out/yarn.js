"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rebuild = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _bluebirdLstC2;

function _load_bluebirdLstC2() {
    return _bluebirdLstC2 = _interopRequireDefault(require("bluebird-lst-c"));
}

let rebuild = exports.rebuild = (() => {
    var _ref = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (appDir, electronVersion) {
        let arch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.arch;
        let additionalArgs = arguments[3];

        const deps = new Set();
        yield dependencies(appDir, false, deps);
        const nativeDeps = yield (_bluebirdLstC2 || _load_bluebirdLstC2()).default.filter(deps, function (it) {
            return (0, (_util || _load_util()).exists)((_path || _load_path()).join(it, "binding.gyp"));
        }, { concurrency: 8 });
        if (nativeDeps.length === 0) {
            return;
        }
        (0, (_log || _load_log()).log)(`Rebuilding native app dependencies for arch ${ arch } to ${ appDir }`);
        let execPath = process.env.npm_execpath || process.env.NPM_CLI_JS;
        const execArgs = ["run", "install", "--"];
        if (execPath == null) {
            if (process.env.FORCE_YARN === "true") {
                execPath = process.platform === "win32" ? "yarn.cmd" : "yarn";
            } else {
                execPath = process.platform === "win32" ? "npm.cmd" : "npm";
            }
        } else {
            execArgs.unshift(execPath);
            execPath = process.env.npm_node_execpath || process.env.NODE_EXE || "node";
        }
        const gypHome = (_path || _load_path()).join((0, (_os || _load_os()).homedir)(), ".electron-gyp");
        const env = Object.assign({}, process.env, {
            HOME: gypHome,
            USERPROFILE: gypHome
        });
        execArgs.push("--disturl=https://atom.io/download/electron");
        execArgs.push(`--target=${ electronVersion }`);
        execArgs.push("--runtime=electron");
        execArgs.push(`--arch=${ arch }`);
        execArgs.push.apply(execArgs, _toConsumableArray(additionalArgs));
        for (let dir of nativeDeps) {
            yield (0, (_util || _load_util()).spawn)(execPath, execArgs, {
                cwd: dir,
                env: env
            });
        }
    });

    return function rebuild(_x2, _x3, _x4, _x5) {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=yarn.js.map


exports.installDependencies = installDependencies;
exports.getGypEnv = getGypEnv;
exports.dependencies = dependencies;

var _path;

function _load_path() {
    return _path = _interopRequireWildcard(require("path"));
}

var _log;

function _load_log() {
    return _log = require("./util/log");
}

var _os;

function _load_os() {
    return _os = require("os");
}

var _util;

function _load_util() {
    return _util = require("./util/util");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function installDependencies(appDir, electronVersion) {
    let arch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.arch;
    let forceBuildFromSource = arguments[3];
    let additionalArgs = arguments[4];

    return (0, (_log || _load_log()).task)(`Installing app dependencies for arch ${ arch } to ${ appDir }`, spawnNpmProduction(appDir, forceBuildFromSource, getGypEnv(electronVersion, arch), additionalArgs));
}
function getGypEnv(electronVersion, arch) {
    const gypHome = (_path || _load_path()).join((0, (_os || _load_os()).homedir)(), ".electron-gyp");
    return Object.assign({}, process.env, {
        npm_config_disturl: "https://atom.io/download/electron",
        npm_config_target: electronVersion,
        npm_config_runtime: "electron",
        npm_config_arch: arch,
        HOME: gypHome,
        USERPROFILE: gypHome
    });
}
function spawnNpmProduction(appDir, forceBuildFromSource, env, additionalArgs) {
    let npmExecPath = process.env.npm_execpath || process.env.NPM_CLI_JS;
    const npmExecArgs = ["install", "--production"];
    const isNotYarn = npmExecPath == null || !(npmExecPath.indexOf("yarn") !== -1);
    if (isNotYarn) {
        if (process.env.NPM_NO_BIN_LINKS === "true") {
            npmExecArgs.push("--no-bin-links");
        }
        npmExecArgs.push("--cache-min", "999999999");
    }
    if (npmExecPath == null) {
        npmExecPath = process.platform === "win32" ? "npm.cmd" : "npm";
    } else {
        npmExecArgs.unshift(npmExecPath);
        npmExecPath = process.env.npm_node_execpath || process.env.NODE_EXE || "node";
    }
    if (isNotYarn && forceBuildFromSource) {
        npmExecArgs.push("--build-from-source");
    }
    if (additionalArgs) {
        if (Array.isArray(additionalArgs)) {
            npmExecArgs.push.apply(npmExecArgs, _toConsumableArray(additionalArgs));
        } else {
            npmExecArgs.push(additionalArgs);
        }
    }
    return (0, (_util || _load_util()).spawn)(npmExecPath, npmExecArgs, {
        cwd: appDir,
        env: env || process.env
    });
}
let readInstalled = null;
function dependencies(dir, extraneousOnly, result) {
    if (readInstalled == null) {
        readInstalled = (_bluebirdLstC2 || _load_bluebirdLstC2()).default.promisify(require("read-installed"));
    }
    return readInstalled(dir).then(it => flatDependencies(it, result, new Set(), extraneousOnly));
}
function flatDependencies(data, result, seen, extraneousOnly) {
    const deps = data.dependencies;
    if (deps == null) {
        return;
    }
    for (let d of Object.keys(deps)) {
        const dep = deps[d];
        if (typeof dep !== "object" || !extraneousOnly && dep.extraneous || seen.has(dep)) {
            continue;
        }
        if (extraneousOnly === dep.extraneous) {
            seen.add(dep);
            result.add(dep.path);
        } else {
            flatDependencies(dep, result, seen, extraneousOnly);
        }
    }
}